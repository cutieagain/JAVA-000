学习笔记

极客时间java第一周

Java核心技术，基础知识

编程语言
面向过程，面向对象，面向函数
静态类型，动态类型
编译执行，解释执行
有虚拟机，无虚拟机
有gc，无gc（内存管理器）

Golang和rust无虚拟机，但是可以编译的时候进行gc

Java是一种面向对象，静态类型，编译执行，有vm/gc运行时，跨平台的高级语言

编程语言跨平台
源代码跨平台（c++）linux上是.so，windows是.dll和.exe，二进制跨平台（java）编译成.class文件，分发.class字节码文件
Java是跨平台，低版本兼容的，生态系统特别强大

java，c++，rust的区别
C/c++ 完全相信而且管着程序员，让大家自行管理内存，可以编写很自由的代码，但一不小心就会造成内存泄漏等问题，导致程序崩溃
Java/golang完全不相信程序员，但是也惯着程序员。所有的内存生命周期都由jvm运行时统一管理。在绝大部分的场景下，你可以非常自由的写代码，而且不用关心内存到底是什么情况。内存使用有问题的时候，我们可以通过jvm来进行信息相关
@@

字节码，类加载器，虚拟机
文件系统中的字节码文件，通过虚拟机的类加载器，生成对象实例

Java字节码的技术
研究一段代码的细节，通过字节码找到原因

什么是字节码
Java bytecode由单字节（byte）的指令组成，理论上最多支持256个操作码（opcode）。实际上java只使用了200个左右的操作码，还有一些操作码则保留给调试操作

根据指令的性质，主要分为4个大类：
1、栈操作指令，包括与局部变量交互的指令
2、程序流程控制指令
3、对象操作指令，包括方法调用指令
4、算数运算以及类型转换指令

生成字节码
编写一个类
编译.java文件
查看字节码 javap -c 包名.类名（这个是.class文件）
进一步查看字节码  javap -c -verbose 包名.类名（这个是.class文件）

字节码运行时结构
Jvm是一台基于栈的计算机器
每个线程都有一个独属于自己的线程栈（jvm stack），用于存储
@

从助记符到二进制

四则运算的例子

数值处理与本地变量表




对字节码来说
Int是最小单位 int 32位，4个byte
long 64位
float 32位
double 64位
bool，byte都是用int表示

方法调用的指令
invokestatic 调用静态方法
Invokespecial 调用构造函数，也可以调用同一个类中的private方法，以及课件超类的方法
Invokevirtual 如果是具体类型的目标对象，用于调用公共，受保护和package级别的私有方法
invokeinterface 通过接口引用调用方法
invokedynamic 动态类型语言 @


Jvm类加载器
类的生命周期
1、加载 loading 找class文件
2、验证 verification 验证格式，依赖
3、准备 preparation 静态字段，方法表
4、解析 resolution 符号解析为引用
2，3，4 为链接
5、初始化 initialization 构造器，静态变量赋值，静态代码块
6、使用 using
7、卸载 unloading

类的加载时机
1、当虚拟机启动时候，初始化用户指定的主类，就是启动执行main方法所在的类
2、当遇到用以新建目标类实例的new指令时候，初始化new指令的目标类，就是new一个类的时候需要初始化
3、当遇到调用静态方法的指令时，初始化该静态方法所在的类
4、当遇到访问静态字段的指令时，初始化该静态字段所在的类
5、子类的初始化会出发父类的初始化
6、如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化
7、使用反射api对某个类进行反射调用时，初始化这个类，其实跟前面一页，反射调用要么是已经有实例了，要么是静态方法，都需要初始化
8、当初次调用methodheadle实例时候，初始化该methodhandle指向的方法所在的类

 不会初始化（可能被加载）
1、通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化
2、定义对象数组，不会触发该类的初始化
3、常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类
4、通过类名获取class对象，不会触发类的初始化，Hello.class不会让Hello类初始化
5、通过Class.forName加载指定的类时候，如果指定参数initialize为false时候，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName(“jvm.hello”)默认会加载Hello类
6、通过ClassLoader默认的loadClass方法，爷不会触发初始化动作（加载了，但是不会初始化）

三类加载器
1、启动类加载器 BootstrapClassLoader
2、拓展类加载器 ExtClassLoader
3、应用类加载器 AppClassLoader

加载器的特点

jdk9之前


1、双亲委托 类加载的时候，子类会查看父加载器是否有，父加载器没有，则去祖父加载器查看，
2、负责依赖
3、缓存加载 类加载的内容进行缓存

自定义classloader
自定义类加载器，实现同一个类不同加载，模块化


添加引用类的几种方式
1、放到jdk的lib/ext下，或者-Djava.ext.dirs
2、java -cp/classpath或者class文件放到当前路径
3、自定义ClassLoader加载
4、拿到当前执行类的ClassLoader，反射调用addUrl方法添加Jar货路径（JDK9无效）


Jvm内存模型
每个线程都只能访问自己的线程栈
每个线程都不能访问（看不见）其他线程的局部变量
所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的
线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身
堆内存中包含了java代码中创建的所有对象，不管是哪个线程创建的。其中也涵盖了包装类型，如Byte，Integer，Long
不管是创建一个对象并将其复制给局部变量，还是复制给另一个对象的成员变量，创建的对象都会被保存到堆内存中





如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上
如果是对象引用，则栈中局部变量槽位中保存着的对象的引用地址，而实际的对象内容保存在堆中
对象的成员变量与对象本身一起存储在堆上，不管成员变量的类型是原生数值还是对象引用
类的静态变量则和类定义一样都保存在堆中

总结一下，方法中使用的原生数据类型和对象引用地址在栈上存储，对象，对象成员与类定义，静态变量在堆上
堆内存又成为“共享堆”，堆中的所有对象，可以被所有线程访问，只要他们能拿到对象的引用地址
如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量
如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量的副本是独立的


Jvm内存整体结构

每启动一个线程，jvm就会在栈空间栈分配对应的线程栈，比如1mb空间（-Xss1m）
线程栈也叫做java方法栈。如果使用了JNI方法，则会分配一个单独的本地方法栈（Native Stack）
线程执行过程中，一般会有多个方法组成调用栈（Stack Trace），比如A调用B，B调用C，每执行到一个方法，就会创建对应的栈帧



栈帧是一个逻辑上的概念，具体的大小是一个方法编写完成后基本上就能确定
比如返回值需要有一个空间存放，每个局部变量都需要对应的地址空间，此外还有给指令使用的操作数栈，以及class指针（标识这个栈帧对应的是哪个类的方法，指向非队）



堆内存是所有线程公用的内存空间，jvm将heap内存分为年轻代（young generation）和老年代（old generation，也叫tenured）两部分
年轻代还划分为3跟内存池，新生代（eden space）和存货去（survivor space），在大部分gc算法中有2个存活区（s0和s1），在我们可以观察到的任何时刻，s0和s1总有一个是空的，但是一般比较小，也不浪费多少空间
Non-heap本质上还是heap，只是一般不归gc管理，里面划分为3个内存池
Metaspace，以前叫持久代（永久代，permanent generation），java 8换了个名字叫metaspace。
ccs，compressed class space，存放class信息的，和metaspace有交叉
Code cache，存放jit编译器编译后的本地机器代码


Cpu与内存行为

Cpu乱序执行
volatile关键字
原子性操作
内存屏障

小结：什么是jvm？

Jvm启动参数



































































